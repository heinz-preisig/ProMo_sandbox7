1 :: zero =  Instantiate ( value , value )
2 :: one =  Instantiate ( value , value )
3 :: onehalf =  Instantiate ( value , value )
4 :: to =  Instantiate ( t , value )
5 :: te =  Instantiate ( t , value )
6 :: p =  neg ( ParDiff ( U , V ) )
7 :: T =  ParDiff ( U , S )
9 :: H =  U - p . V
10 :: A =  U - T . S
11 :: G =  U + p . V - T . S
12 :: v_x =  ParDiff ( r_x , t )
13 :: v_y =  ParDiff ( r_y , t )
14 :: v_z =  ParDiff ( r_z , t )
15 :: v =  Stack ( v_x , v_y , v_z )
16 :: Boltzmann =  Instantiate ( S , value )
17 :: GasConstant =  Avogadro . Boltzmann
18 :: Cp =  ParDiff ( H , T )
19 :: Cv =  ParDiff ( U , T )
22 :: kq_x =  inv ( V ) . ParDiff ( U , T ) . v_x
23 :: kq_y =  inv ( V ) . ParDiff ( U , T ) . v_y
24 :: kq_z =  inv ( V ) . ParDiff ( U , T ) . v_z
25 :: kq =  Stack ( kq_x , kq_y , kq_z )
32 :: chem_pot =  ParDiff ( U , n )
37 :: kc_x =  ( Mm | S in N & S | inv ( chem_pot ) ) . inv ( V ) . ParDiff ( U , p ) . v_x
38 :: kc_y =  ( Mm | S in N & S | inv ( chem_pot ) ) . inv ( V ) . ParDiff ( U , p ) . v_y
39 :: kc_z =  ( Mm | S in N & S | inv ( chem_pot ) ) . inv ( V ) . ParDiff ( U , p ) . v_z
40 :: kc =  Stack ( kc_x , kc_y , kc_z )
41 :: kd_x =  inv ( chem_pot ) . ( v_x : ( inv ( V ) : ParDiff ( U , chem_pot ) ) )
42 :: kd_y =  inv ( chem_pot ) . ( v_y : ( inv ( V ) : ParDiff ( U , chem_pot ) ) )
43 :: kd_z =  inv ( chem_pot ) . ( v_z : ( inv ( V ) : ParDiff ( U , chem_pot ) ) )
44 :: kd =  Stack ( kd_x , kd_y , kd_z )
45 :: h =  H : inv ( n )
46 :: d =  sign ( F | N | p )
47 :: m =  Mm | S in N & S | n
49 :: density =  m . inv ( V )
51 :: F_NS_AS =  F : P_NS_AS
55 :: T_NK =  P_N_NK | N | T
64 :: Ea =  Instantiate ( P_N_NK | N | GasConstant . T_NK , value )
65 :: K_NK =  Ko : exp ( neg ( Ea ) . inv ( GasConstant | N | P_N_NK . T_NK ) )
69 :: N_NS_NK =  P_S_NS | S | ( ( P_K_NK . T_NK . inv ( T_NK ) ) | K | N )
71 :: Ayz =  r_y . r_z
72 :: Axz =  r_x . r_z
73 :: Axy =  r_x . r_y
74 :: fV =  inv ( density ) . kc_x . Ayz . D | N | p
80 :: fnd_AS =  Ayz : neg ( kd_x ) . D_NS_AS | N & S | chem_pot
81 :: fnd =  F_NS_AS | A & S | fnd_AS
82 :: fHd_A =  ( F_NS_AS | N & S | h ) | S in A & S | fnd_AS
83 :: fHd =  F | A | fHd_A
84 :: c =  inv ( V ) : n
85 :: c_AS =  ( onehalf . ( F_NS_AS - d : abs ( F_NS_AS ) ) ) | N & S | c
86 :: fnc_AS =  fV : c_AS
87 :: fnc =  F_NS_AS | A & S | fnc_AS
90 :: c_KS =  c | N & S | P_NS_KS
91 :: co_KS =  Instantiate ( c_KS , value )
92 :: phi_KS =  Product ( c_KS . inv ( co_KS ) , N )
93 :: xi =  K_NK . P_NK_KS | K & S | phi_KS
94 :: pn =  V : ( N_NS_NK | N & K | xi )
95 :: dndt =  fnc + fnd + pn
96 :: fHc_A =  ( F_NS_AS | N & S | h ) | S in A & S | fnc_AS
97 :: fHc =  F | A | fHc_A
98 :: fw_A =  Instantiate ( fHc_A , value )
99 :: fw =  F | A | fw_A
100 :: fq_A_x =  Ayz . kq_x . D | N | T
101 :: fq =  F | A | fq_A_x
102 :: dHdt =  fHc + fHd + fq + fw
103 :: xo =  Instantiate ( x , value )
104 :: e =  mc - setpoint
106 :: dxdt =  Ax | N | x + Bx | A | e
112 :: x =  Integral ( I_N_D | D | dxdt :: t in [ to , te ] )
113 :: T =  Instantiate ( T , value )
114 :: chem_pot =  Instantiate ( chem_pot , value )
115 :: p =  Instantiate ( p , value )
116 :: n =  Integral ( dndt :: t in [ to , te ] ) + no
117 :: T_ref =  Instantiate ( T , value )
120 :: cp =  Cp . inv ( m )
121 :: cv =  Cv . inv ( m )
122 :: H =  m . Integral ( cp :: T in [ T_ref , T ] )
123 :: H =  Integral ( dHdt :: t in [ to , te ] ) + Ho
124 :: no =  Instantiate ( n , value )
125 :: Ho =  Instantiate ( H , value )
126 :: intensities =  MixedStack ( p , T , chem_pot , c )
127 :: c =  Instantiate ( c , value )
128 :: dHdt =  Instantiate ( dHdt , zero )
129 :: dndt =  Instantiate ( dndt , zero )
130 :: phi =  MixedStack ( n , H )
131 :: kq_x =  Instantiate ( kq_x , value )
132 :: kq_y =  Instantiate ( kq_y , value )
133 :: kq_z =  Instantiate ( kq_z , value )
134 :: kc_x =  Instantiate ( kc_x , value )
135 :: kc_y =  Instantiate ( kc_y , value )
136 :: kc_z =  Instantiate ( kc_z . value  )
137 :: kd_x =  Instantiate ( kd_x , value )
138 :: kd_y =  Instantiate ( kd_y , value )
139 :: h =  Instantiate ( h , value )
140 :: cp =  Instantiate ( cp , value )
141 :: cv =  Instantiate ( cv , value )
142 :: Mm =  Instantiate ( Mm , value )
143 :: data =  MixedStack ( kq , kc , kd , h , cp , cv , Mm , density )
144 :: Cx =  Instantiate ( Cx , value )
145 :: Dx =  Instantiate ( Dx , value )
146 :: setpoint =  Instantiate ( setpoint , value )
147 :: D_A =  Instantiate ( D_A , value )
148 :: Ax =  Instantiate ( Ax , value )
149 :: Bx =  Instantiate ( Bx , value )
150 :: y =  Cx | N | x + D_A . e
153 :: y =  D_A . e
154 :: density =  Instantiate ( density , value )
155 :: u =  one . y
161 :: cnorm =  ones_NS | S in N & S | c
162 :: x_frac =  inv ( cnorm ) : c
171 :: additiveFraction =  Instantiate ( additiveFraction , value )
176 :: Ue =  inv ( Charge ) . U
177 :: current =  TotalDiff ( Charge , t )
178 :: elResistance =  inv ( current ) . Ue
179 :: elConducC =  inv ( elResistance ) . additiveFraction
180 :: elResistance =  Instantiate ( elResistance , value )
181 :: Ue =  inv ( elConducC ) . current
182 :: dUedt =  one_N . Ue
183 :: dUedt =  Instantiate ( dUedt , zero )
185 :: current =  Root ( dUedt )
186 :: courrentA =  one_A . current
187 :: elConduc =  inv ( elResistance )
188 :: Ue =  elResistance . current
189 :: current =  Root ( Ue )
190 :: measuredCurrent =  current
191 :: measuredPotentialDiff =  Ue
192 :: measuredAdditive =  additiveFraction
193 :: compResistance =  inv ( measuredCurrent ) . measuredPotentialDiff
194 :: store =  MixedStack ( measuredCurrent , measuredPotentialDiff , compResistance , measuredAdditive )
195 :: Ue =  Instantiate ( Ue , value )
